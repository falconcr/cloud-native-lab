{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u2601\ufe0f cloud-native-lab","text":"<p>Welcome to cloud-native-lab, a hands-on journey to learn and master Cloud Native technologies from the ground up. This repository is designed for both beginners and experienced practitioners who want to build real-world skills in the modern cloud-native ecosystem.</p>"},{"location":"#what-youll-learn","title":"\ud83d\ude80 What You'll Learn","text":"<p>Through practical labs and guided exercises, you'll explore:</p> <ul> <li>\ud83d\udc33 Docker &amp; Containerization Basics  </li> <li>\u2638\ufe0f Kubernetes Fundamentals and Advanced Use  </li> <li>\ud83d\udd01 GitOps with Flux and ArgoCD  </li> <li>\ud83d\udd0d Observability with Prometheus, Grafana, OpenTelemetry  </li> <li>\ud83d\udd12 Security Best Practices for Containers &amp; Kubernetes  </li> <li>\ud83d\udce6 CI/CD Pipelines and Progressive Delivery  </li> <li>\ud83e\udde9 Service Meshes like Istio and Linkerd  </li> <li>\u2601\ufe0f Cloud-native development patterns and practices</li> </ul>"},{"location":"#requirements","title":"\ud83e\uddf0 Requirements","text":"<p>To follow along, you\u2019ll need:</p> <ul> <li>Basic terminal/command-line knowledge</li> <li>A GitHub account</li> <li>Docker</li> <li>kubectl</li> <li>Minikube or Kind</li> <li>Optional: access to a cloud provider (AWS, GCP, Azure)</li> </ul>"},{"location":"#who-is-this-for","title":"\ud83d\udc68\u200d\ud83c\udfeb Who Is This For?","text":"<ul> <li>Students or professionals transitioning to DevOps or Cloud roles</li> <li>Developers who want to understand Kubernetes and modern infrastructure</li> <li>Anyone preparing for certifications like CKA, CKAD, or KCNA</li> </ul>"},{"location":"#contributions-welcome","title":"\ud83e\udd1d Contributions Welcome","text":"<p>Feel free to open issues, submit pull requests, or suggest improvements. Let\u2019s build this learning journey together.</p>"},{"location":"#license","title":"\ud83d\udcdc License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"01-containers/001-containers/","title":"\ud83c\udf93 Lesson: Why Containers are a pillar in Cloud Native","text":""},{"location":"01-containers/001-containers/#why-containers-matter-in-the-cloud-native-world","title":"\ud83e\uddf1 Why Containers Matter in the Cloud Native World","text":"<p>Let\u2019s start with a basic question:</p> <p>\u2753What does \u201cCloud Native\u201d even mean?</p> <p>Cloud Native is not just about running things in the cloud. It's about designing, building, and running applications that can scale, recover, and evolve quickly \u2014 using modern tools like containers, microservices, orchestration, and DevOps automation.</p> <p>Now\u2026 imagine you're building a car factory. You want every car to be identical, reliable, fast to assemble, and easy to replace if something breaks.</p> <p>That\u2019s exactly what containers help us do with software.</p>"},{"location":"01-containers/001-containers/#what-is-a-container","title":"\ud83e\uddca What Is a Container?","text":"<p>Analogy: A container is like a shipping container for your application.</p> <ul> <li>It packages your app with everything it needs: code, dependencies, runtime, configs \u2014 so it can run anywhere, without the \u201cit works on my machine\u201d problem.</li> <li>It's lightweight, starts very fast, and doesn\u2019t include a full operating system like a virtual machine does.</li> <li>You can run dozens or hundreds of containers on a single host, just like you can stack containers on a ship.</li> </ul> <p>\u2705 Containers bring portability, consistency, and efficiency. That\u2019s why they\u2019re a core pillar of Cloud Native development.</p>"},{"location":"01-containers/001-containers/#docker-vs-podman-and-others","title":"\ud83d\udc33 Docker vs Podman (and Others)","text":"<p>When people hear \u201ccontainers,\u201d most think of Docker. But here\u2019s the key idea:</p> <p>\ud83d\udd11 Containers are a technology, not a product. Docker is just one tool that helps you use containers.</p> <p>Let\u2019s explain the most common tools:</p>"},{"location":"01-containers/001-containers/#docker","title":"\ud83d\udc33 Docker","text":"<p>Docker is the most popular tool to build, run, and manage containers. It gives us:</p> <ul> <li><code>Dockerfile</code> to define how to build images</li> <li><code>docker build</code>, <code>docker run</code>, <code>docker ps</code> and more</li> <li>A great developer experience, stable CLI, and large ecosystem</li> <li>Docker Desktop for Mac/Windows users</li> </ul> <p>It's like using Spotify for music \u2014 it\u2019s not the only way, but it's the one most people use because it's user-friendly and full-featured.</p>"},{"location":"01-containers/001-containers/#podman","title":"\ud83d\udd25 Podman","text":"<p>Podman is a Docker-compatible tool that:</p> <ul> <li>Runs containers without a daemon (more secure)</li> <li>Supports rootless containers</li> <li>Comes by default in many Linux distros (Red Hat, Fedora)</li> </ul> <p>Podman is like a manual stick-shift car \u2014 more control, but a steeper learning curve.</p>"},{"location":"01-containers/001-containers/#other-container-tools","title":"\ud83e\uddf0 Other Container Tools","text":"<ul> <li>containerd: Low-level runtime used under Docker and Kubernetes</li> <li>Buildah: Used to build images without Docker</li> <li>CRI-O: Kubernetes-native container runtime</li> </ul> <p>\ud83e\udde0 So even though we use Docker in this course (because it\u2019s popular, friendly, and well-supported), the skills you learn apply to all these tools. They all follow the same OCI (Open Container Initiative) standards.</p>"},{"location":"01-containers/001-containers/#summary-to-share-with-students","title":"\ud83d\udca1 Summary to Share with Students","text":"Concept Explanation What is a container? A lightweight, portable package of your app + its dependencies Why are containers key? They make apps easy to ship, scale, and update \u2014 perfect for cloud environments Is Docker the only tool? No \u2014 it\u2019s just the most used one. There are others like Podman, containerd, and Buildah Why use Docker? Huge community, excellent tooling, easy for beginners, fast-growing"},{"location":"01-containers/002-docker/","title":"002 docker","text":""},{"location":"01-containers/002-docker/#1-docker-cli-dockerfile-syntax","title":"\ud83d\udc33 1. Docker CLI &amp; Dockerfile Syntax","text":""},{"location":"01-containers/002-docker/#concept","title":"\ud83c\udf93 Concept:","text":"<p>Docker is like a kitchen, and the <code>Dockerfile</code> is your recipe.</p> <p>Imagine you\u2019re a chef. You don\u2019t cook freestyle every time \u2014 you follow a recipe. That\u2019s exactly what a <code>Dockerfile</code> does: it tells Docker how to build your application image.</p> <ul> <li>First, you choose a base image \u2014 like picking the type of kitchen you\u2019ll use (e.g., <code>node:18</code> or <code>python:3.11-slim</code>).</li> <li>Then you add the ingredients \u2014 your code and dependencies.</li> <li>Finally, you define the command to run the app, like turning on the stove.</li> </ul> <p>To build the image from that recipe, you use <code>docker build</code>. That creates a new container image, kind of like baking a cake and wrapping it up for delivery.</p> <p>Once the image is ready, you can run it using <code>docker run</code>, which launches your app inside an isolated container \u2014 like cooking and serving the meal.</p> <p>\ud83d\udc49 To try this: write a <code>Dockerfile</code>, build it, and run it. Example:</p> <pre><code>docker build -t myapp .\ndocker run -p 3000:3000 myapp\n</code></pre> <p>\ud83d\udcda Learn more (official docs)</p>"},{"location":"01-containers/002-docker/#2-docker-compose-for-multi-service-setup","title":"\u2699\ufe0f 2. Docker Compose for Multi-Service Setup","text":""},{"location":"01-containers/002-docker/#concept_1","title":"\ud83c\udf93 Concept:","text":"<p>Most real-world apps are not solo artists \u2014 they\u2019re bands. Your backend is the singer \ud83c\udfa4, your database is the drummer \ud83e\udd41, and maybe your frontend is the DJ \ud83c\udfa7.</p> <p>Managing all these with <code>docker run</code> manually would be chaotic \u2014 like having every musician show up at a different time with no plan.</p> <p>That\u2019s where <code>docker-compose</code> comes in. It\u2019s your conductor.</p> <p>With a <code>docker-compose.yml</code> file, you define multiple services \u2014 each one a container \u2014 and describe how they work together:</p> <ul> <li>Which image or Dockerfile to use</li> <li>Which ports to expose</li> <li>What environment variables or volumes to include</li> <li>How the services connect to each other internally</li> </ul> <p>You then launch all services at once with just:</p> <pre><code>docker-compose up\n</code></pre> <p>They\u2019re all orchestrated and networked automatically \u2014 just like a band in sync.</p> <p>\ud83d\udcda Explore the Compose docs</p>"},{"location":"01-containers/002-docker/#3-base-image-selection-vs-multistage-builds","title":"\ud83d\udce6 3. Base Image Selection vs Multistage Builds","text":""},{"location":"01-containers/002-docker/#concept_2","title":"\ud83c\udf93 Concept:","text":"<p>When building something (like a house), you don\u2019t bring the entire warehouse of tools to the construction site \u2014 just what you need.</p> <p>In Docker, the base image is your starting toolbox. Some are small (<code>alpine</code>, <code>slim</code>), and some are big (with compilers and build tools). Using a lighter image makes your app faster to download and start, and reduces attack surface.</p> <p>A multistage build is a way to use all your tools during the build stage (installing, compiling), but only ship the final clean result.</p> <p>For example:</p> <ol> <li>First stage: build the frontend using Node.js</li> <li>Second stage: copy the built files into a tiny Nginx container</li> </ol> <p>This results in a small, production-ready image without any of the dev tools inside.</p> <pre><code># Stage 1 - build\nFROM node:18 as builder\nWORKDIR /app\nCOPY . .\nRUN npm install &amp;&amp; npm run build\n\n# Stage 2 - run\nFROM nginx:alpine\nCOPY --from=builder /app/dist /usr/share/nginx/html\n</code></pre> <p>\ud83d\udcda Multistage builds guide</p>"},{"location":"01-containers/002-docker/#4-container-networking-and-volumes","title":"\ud83c\udf10 4. Container Networking and Volumes","text":""},{"location":"01-containers/002-docker/#concept_3","title":"\ud83c\udf93 Concept:","text":"<p>Think of each container like a room in a house.</p> <ul> <li>Ports are the doors \u2014 they allow things to go in and out.</li> <li>Networks are like walkie-talkies between rooms \u2014 containers can talk to each other over a shared private network.</li> <li>Volumes are shared cabinets \u2014 places to store things that shouldn\u2019t be lost when the container is deleted (like databases or uploaded files).</li> </ul> <p>By default, containers are isolated. But with Docker Compose or custom networks, they can talk to each other by name (e.g., <code>db:5432</code>).</p> <p>Volumes are created to make data persist. For example, if you delete a container, but want the database data to survive, you mount a volume like this:</p> <pre><code>volumes:\n  - dbdata:/var/lib/postgresql/data\n</code></pre> <p>This way, even if your database container crashes or is updated, the data stays safe.</p> <p>\ud83d\udcda Docker networking docs \ud83d\udcda Docker volumes docs</p>"},{"location":"01-containers/002-docker/#5-debugging-containers-exec-logs-inspect","title":"\ud83e\uddf0 5. Debugging Containers (exec, logs, inspect)","text":""},{"location":"01-containers/002-docker/#concept_4","title":"\ud83c\udf93 Concept:","text":"<p>A container is like a sealed box running your application. When something doesn\u2019t work, you need to become a mechanic with the right tools.</p> <ul> <li>Use <code>docker logs</code> to see what\u2019s going wrong \u2014 it\u2019s like reading the warning lights on a car dashboard.</li> <li>Use <code>docker exec -it &lt;container&gt; /bin/sh</code> to get inside the container \u2014 like opening the hood to check things directly.</li> <li>Use <code>docker inspect</code> to get detailed information about the container \u2014 the full spec sheet, network, volumes, environment variables, and more.</li> </ul> <p>When your app doesn\u2019t start or behaves strangely, this is how you investigate.</p> <pre><code>docker logs myapp\ndocker exec -it myapp /bin/sh\ndocker inspect myapp\n</code></pre> <p>These tools are essential for real-world debugging and help you build the habit of not guessing \u2014 but inspecting and understanding.</p> <p>\ud83d\udcda Official debugging docs</p>"}]}